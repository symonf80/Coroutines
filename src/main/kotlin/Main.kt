import kotlinx.coroutines.*
import kotlin.coroutines.EmptyCoroutineContext


// ------Cancellation------

// № 1:
//fun main() = runBlocking {
//    val job = CoroutineScope(EmptyCoroutineContext).launch {
//        launch {
//            delay(500)
//            println("ok") // <-- НЕ ОТРАБОТАЕТ
//        }
//        launch {
//            delay(500)
//            println("ok")
//        }
//    }
//    delay(100)
//    job.cancelAndJoin()
//}
/** Создаются две дочерние корутины внутри родительской. Обе эти корутины выполняют задержку в 0.5 сек. и выводят OK.
Они так же запускаются одновременно и вывод OK будет происходить параллельно. После создания этих корутин,
вызывается delay(100) и означает, что основная корутина будет ждать 100 м.сек. После вызова job.cancelAndJoin,
Job будет отменен, и все корутины, запущенные внутри Job, тоже будут отменены. Значит и строка, помеченная в коде
символом //<-- не отработает, так как не успеет выполниться. */
//=====================================================================================================================

// № 2:
//fun main() = runBlocking {
//    val job = CoroutineScope(EmptyCoroutineContext).launch {
//        val child = launch {
//            delay(500)
//            println("ok") // <-- НЕ ОТРАБОТАЕТ
//        }
//        launch {
//            delay(500)
//            println("ok")
//        }
//        delay(100)
//        child.cancel()
//    }
//    delay(100)
//    job.join()
//}
/** Создаются две дочерние корутины внутри родительской. Первая корутина child имеет задержку в 0.5 сек. и выводит OK.
Вторая корутина также выполняет задержку в 0.5 сек. и выводит OK, но она не имеет отношения к child.
После этих корутин вызывается delay(100), что означает, что родительская корутина будет ожидать 100 м.сек., перед тем,
как вызовется child.cancel. После вызова child.cancel(), корутина child будет отменена, так как вызов cancel()
применяется только к этой корутине. Таким образом, код в строке с пометкой //<-- не отработает, так как корутина child
будет отменена до завершения задержки и вывода OK. */

//======================================================================================================================

//------Exception Handling------
// № 1:
//fun main() {
//    with(CoroutineScope(EmptyCoroutineContext)) {
//        try {
//            launch {
//                throw Exception("something bad happened")
//            }
//        } catch (e: Exception) {
//            e.printStackTrace() // <-- НЕ ОТРАБОТАЕТ
//        }
//    }
//    Thread.sleep(1000)
//}
/** Создаётся корутина в блоке launch, и в этой корутине выбрасывается исключение "something bad happened".
Это исключение выбрасывается внутри этой корутины, а блок catch находится вне этой корутины. Получается, что исключение
будет обработано внутри корутины, исключение будет привязано к этой корутине, но код в блоке catch не выполнится,
так как корутина будет завершена из-за выбрасывания исключения. Таким образом строка в коде с пометкой //<--
не отработает, так как исключение будет поймано внутри корутины, а не вне её. */
//=====================================================================================================================

// № 2:
//fun main() {
//    CoroutineScope(EmptyCoroutineContext).launch {
//        try {
//            coroutineScope {
//                throw Exception("something bad happened")
//            }
//        } catch (e: Exception) {
//            e.printStackTrace() // <-- ОТРАБОТАЕТ
//        }
//    }
//    Thread.sleep(1000)
//}
/** Создаётся корутина в блоке launch, и в этой корутине вызывается coroutineScope, который позволяет создать Scope
для перехвата ошибок во вложенных корутинах. Внутри coroutineScope выбрасывается исключение "something bad happened".
В блоке catch исключение будет успешно поймано. После того как исключение поймано строка e.printStackTrace будет вызвана
и выведет стек вызовов и информацию об исключении. После выполнения корутины, выполнится поток заснет на 1 сек.,
что даст корутине достаточно времени для выполнения. Код в строчке с пометкой //<-- отработает. */
//=====================================================================================================================

// № 3:
//fun main() {
//    CoroutineScope(EmptyCoroutineContext).launch {
//        try {
//            supervisorScope {
//                throw Exception("something bad happened")
//            }
//        } catch (e: Exception) {
//            e.printStackTrace() // <-- ОТРАБОТАЕТ
//        }
//    }
//    Thread.sleep(1000)
//}
/** Создаётся корутина в блоке launch. Внутри этой корутины вызывается supervisorScope, который также создает новую
корутину (supervisor), что означает если внутри этой корутины произойдет исключение, то оно не приведет к отмене
родительской корутины. Внутри supervisorScope бросается исключение "something bad happened". Затем это исключение
перехватывается с помощью catch и выводится с помощью e.printStackTrace. После этого вызывается Thread.sleep(1000),
что приостанавливает основной поток на 1 секунду, так как без этой задержки программа может завершиться до
завершения выполнения корутины. Значит код в строчке с пометкой //<-- отработает. */
//=====================================================================================================================

// № 4:
//fun main() {
//    CoroutineScope(EmptyCoroutineContext).launch {
//        try {
//            coroutineScope {
//                launch {
//                    delay(500)
//                    throw Exception("something bad happened") // <-- НЕ ОТРАБОТАЕТ
//                }
//                launch {
//                    throw Exception("something bad happened")
//                }
//            }
//        } catch (e: Exception) {
//            e.printStackTrace()
//        }
//    }
//    Thread.sleep(1000)
//}
/**Нет, т.к. в соседней корутине без задержки (delay) произойдет исключение, а scope функция coroutineScope{}
пробрасывает исключения от дочерних корутин и в случае если происходит исключение в одной асинхронной задаче
все остальные отменяются.Текущая корутина отменится на выполнении suspend функции delay(500) в связи с тем
что произошло исключение в асинхронной задаче в скоупе coroutineScope.*/
//=====================================================================================================================
// № 5:
fun main() {
    CoroutineScope(EmptyCoroutineContext).launch {
        try {
            supervisorScope {
                launch {
                    delay(500)
                    throw Exception("something bad happened1") // <-- ОТРАБОТАЕТ
                }
                launch {
                    throw Exception("something bad happened2")
                }
            }
        } catch (e: Exception) {
            e.printStackTrace() // <-- НЕ ОТРАБОТАЕТ
        }
    }
    Thread.sleep(1000)
}
/** Первый случай отработает,так как  supervisorScope не отменяет другие дочерние элементы, если один из них завершается сбоем.
  Но поскольку дочерние корутины были запущены внутри блока try-catch, то в родительской корутине исключения выброшеные
 дочерними корутинами не перехватываются и второй случай не отработает.*/
//======================================================================================================================

// № 6:
//fun main() {
//    CoroutineScope(EmptyCoroutineContext).launch {
//        CoroutineScope(EmptyCoroutineContext).launch {
//            launch {
//                delay(1000)
//                println("ok") // <-- НЕ ОТРАБОТАЕТ
//            }
//            launch {
//                delay(500)
//                println("ok")
//            }
//            throw Exception("something bad happened")
//        }
//    }
//    Thread.sleep(1000)
//}
/**Нет, т.к. исключение брошенное в CoroutineScope отменит всю иерархию Job, в т.ч. дочернюю корутину на моменте
выполнения suspend функции delay(1000) и prinln() вызван не будет.*/
//=====================================================================================================================
// № 7:
//fun main() {
//    CoroutineScope(EmptyCoroutineContext).launch {
//        CoroutineScope(EmptyCoroutineContext + SupervisorJob()).launch {
//            launch {
//                delay(1000)
//                println("ok") // <-- НЕ ОТРАБОТАЕТ
//            }
//            launch {
//                delay(500)
//                println("ok")
//            }
//            throw Exception("something bad happened")
//        }
//    }
//    Thread.sleep(1000)
//}
/** Создаётся корутина внутри CoroutineScope. Внутри этой корутины создается еще одна дополнительная корутина
с добавлением SupervisorJob - который означает, что если одна из дочерних корутин выбрасывает исключение, это не влияет
на выполнение других дочерних корутин. Однако, в данном случае, мы создаем дочернюю корутину без SupervisorJob, поэтому
она все равно влияет на выполнение всех дочерних корутин. Внутри дополнительной корутины создаются две дочерние:
одна с задержкой 1 сек., другая с задержкой 0.5 сек. После создания этих корутин следует строка throw Exception().
Исключение выбрасывается внутри дополнительной корутины, и так как эта корутина не имеет своего SupervisorJob,
оно влияет на выполнение всех корутин, созданных внутри CoroutineScope с SupervisorJob. Исключение влияет на обе
дочерние корутины: первая корутина, которая должна была выполнить println("ok"), и вторая. Программа завершается с
исключением, и строка println("ok") не будет выполнена. Значит код в строчке с пометкой //<-- не отработает.
 */